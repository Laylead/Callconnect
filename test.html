<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Watch Party ‚Äî Premium Experience</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --accent: #4f46e5;
      --accent-hover: #4338ca;
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    html, body {
      height: 100%;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text-main);
      background: radial-gradient(circle at top left, #1d4ed8 0%, #020617 35%, #000 100%);
      overflow: hidden;
    }
    
    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    #topbar {
      display: flex;
      align-items: center;
      padding: 10px 14px;
      gap: 10px;
      background: linear-gradient(to right, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(148,163,184,0.12);
      z-index: 20;
      flex-shrink: 0;
    }
    
    #appTitle {
      font-weight: 700;
      font-size: 16px;
    }
    
    #roomInfo {
      font-size: 12px;
      color: var(--text-soft);
    }
    
    .top-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      font-size: 13px;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .btn:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn.grey {
      background: rgba(15,23,42,0.9);
      color: var(--text-main);
      border: 1px solid rgba(148,163,184,0.18);
    }
    
    .btn.grey:hover {
      background: rgba(15,23,42,1);
      border-color: rgba(148,163,184,0.3);
    }
    
    .btn.small {
      padding: 6px 10px;
      font-size: 12px;
    }
    
    .emoji-btn {
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.18);
    }
    
    .emoji-btn:hover {
      background: rgba(15,23,42,1);
      transform: scale(1.1);
    }
    
    .main-container {
      display: flex;
      flex: 1;
      gap: 12px;
      padding: 12px;
      min-height: 0;
      overflow: hidden;
    }
    
    #video-container {
      flex: 3;
      min-width: 60%;
      display: flex;
      flex-direction: column;
      background: linear-gradient(180deg, rgba(15,23,42,0.8), rgba(15,23,42,0.95));
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      position: relative;
      min-height: 0;
    }
    
    #controls-container {
      flex: 2;
      min-width: 40%;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
      overflow-y: auto;
      padding-right: 4px;
    }
    
    #player-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      flex: 1;
      min-height: 240px;
    }
    
    video, #ytPlayerIframe {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
      object-fit: contain;
    }
    
    #overlay-block {
      position: absolute;
      inset: 0;
      z-index: 40;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.18);
      backdrop-filter: blur(2px);
      pointer-events: auto;
    }
    
    #overlay-block.hidden {
      display: none;
    }
    
    #overlay-block .hint {
      background: rgba(15,23,42,0.9);
      padding: 10px 16px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.18);
      font-size: 14px;
      color: var(--text-soft);
    }
    
    canvas#drawingCanvas {
      position: absolute;
      inset: 0;
      z-index: 45;
      pointer-events: none;
    }
    
    #reactions {
      position: absolute;
      right: 12px;
      top: 12px;
      z-index: 60;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
    }
    
    .reaction-bubble {
      background: rgba(15,23,42,0.98);
      padding: 6px 10px;
      border-radius: 18px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.5);
      font-size: 18px;
      animation: floatUp 3s ease forwards;
    }
    
    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translateY(-60px); opacity: 0; }
    }
    
    .panel {
      background: rgba(15,23,42,0.92);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(148,163,184,0.08);
      display: flex;
      flex-direction: column;
    }
    
    .panel-header {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-soft);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .panel-body {
      flex: 1;
      overflow: auto;
      font-size: 13px;
    }
    
    #controls-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    
    select {
      background: rgba(15,23,42,0.9);
      color: var(--text-main);
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.2);
      padding: 6px 10px;
      font-size: 13px;
    }
    
    label.small {
      font-size: 12px;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    #chatMessages {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .chat-msg {
      padding: 10px;
      border-radius: 10px;
      background: rgba(2,6,23,0.6);
      border: 1px solid rgba(148,163,184,0.06);
    }
    
    .chat-meta {
      font-size: 12px;
      color: var(--text-soft);
      margin-bottom: 6px;
    }
    
    #status {
      margin-top: 10px;
      font-size: 14px;
      color: #a5b4fc;
    }
    
    /* Fullscreen Controls */
    #fullscreen-controls {
      position: fixed;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    body:fullscreen #fullscreen-controls,
    body:-webkit-full-screen #fullscreen-controls,
    body:-moz-full-screen #fullscreen-controls {
      opacity: 1;
      pointer-events: all;
    }
    
    .fullscreen-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.18);
      color: var(--text-main);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .fullscreen-btn:hover {
      background: rgba(15,23,42,1);
      transform: scale(1.1);
    }
    
    /* Mobile Responsiveness */
    @media (max-width: 900px) {
      .main-container {
        flex-direction: column;
        padding: 8px;
        gap: 8px;
      }
      
      #video-container {
        min-width: 100%;
        flex: 2;
      }
      
      #controls-container {
        min-width: 100%;
        flex: 1;
        overflow-y: auto;
      }
      
      #controls-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      
      .top-right {
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      
      #fullscreen-controls {
        bottom: 20px;
        top: auto;
        right: 20px;
        transform: none;
        flex-direction: row;
      }
    }
    
    @media (max-width: 600px) {
      #controls-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      
      .btn {
        padding: 6px 10px;
        font-size: 12px;
      }
      
      .panel {
        padding: 10px;
      }
      
      #topbar {
        padding: 8px 12px;
      }
    }
    
    @media (orientation: landscape) and (max-height: 500px) {
      #topbar {
        padding: 6px 10px;
      }
      
      .main-container {
        padding: 6px;
        gap: 6px;
      }
      
      #video-container {
        flex: 3;
      }
      
      #controls-container {
        flex: 2;
      }
    }
    
    /* Voice status indicators */
    .voice-active {
      color: var(--success);
    }
    
    .voice-inactive {
      color: var(--text-soft);
    }
    
    .voice-error {
      color: var(--error);
    }
    
    /* Loading spinner */
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: var(--text-main);
      animation: spin 1s linear infinite;
      display: inline-block;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Improved scrollbars */
    ::-webkit-scrollbar {
      width: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(15,23,42,0.5);
      border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(148,163,184,0.3);
      border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(148,163,184,0.5);
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="topbar">
      <div>
        <div id="appTitle">Watch Party</div>
        <div id="roomInfo"></div>
      </div>
      <div class="top-right" id="topRightControls">
        <button class="btn small emoji-btn" data-emoji="üòÇ">üòÇ</button>
        <button class="btn small emoji-btn" data-emoji="üò±">üò±</button>
        <button class="btn small emoji-btn" data-emoji="ü§®">ü§®</button>
        <button class="btn small emoji-btn" data-emoji="üëè">üëè</button>
      </div>
    </div>

    <div class="main-container">
      <div id="video-container">
        <div id="player-container">
          <video id="html5video" playsinline preload="auto"></video>
          <div id="ytContainer" style="display:none;width:100%;height:100%"><div id="ytPlayerIframe"></div></div>
          <canvas id="drawingCanvas"></canvas>
          <div id="overlay-block" class="hidden"><div class="hint">You're viewing ‚Äî host controls playback</div></div>
          <div id="reactions"></div>
        </div>
        <div id="status"></div>
      </div>

      <div id="controls-container">
        <div class="panel" style="flex:0 0 auto">
          <div class="panel-header">
            <span>Main Controls</span>
            <label class="small">Speed:
              <select id="speedSel">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
              </select>
            </label>
          </div>
          <div id="controls-grid">
            <button id="pauseDiscussBtn" class="btn grey">Pause & Discuss</button>
            <button id="toggleDrawBtn" class="btn grey">Draw</button>
            <button id="clearDrawBtn" class="btn grey">Clear Draw</button>
            <button id="spotlightBtn" class="btn grey">Spotlight</button>
            <button id="focusBtn" class="btn grey">Focus Mode</button>
            <button id="fullscreenBtn" class="btn grey">Fullscreen</button>
          </div>
        </div>

        <div class="panel" style="flex:0 0 auto">
          <div class="panel-header"><span>Voice Talk</span></div>
          <div class="panel-body" style="display:flex;flex-direction:column;gap:8px">
            <button id="holdTalkBtn" class="btn grey">Hold to Talk</button>
            <div id="voiceStatus">Initializing voice...</div>
          </div>
        </div>

        <div class="panel" style="flex:1;min-height:0;display:flex;flex-direction:column">
          <div class="panel-header"><span>Party Chat</span></div>
          <div class="panel-body" id="chatScroll" style="padding:8px;min-height:80px;overflow:auto">
            <div id="chatMessages"></div>
          </div>
          <div id="chatInputRow" style="display:flex;gap:8px;margin-top:10px">
            <input id="chatInput" placeholder="Type a message..." style="flex:1;padding:8px 12px;border-radius:8px;border:1px solid rgba(148,163,184,0.08);background:rgba(2,6,23,0.6);color:var(--text-main)" />
            <button id="chatSendBtn" class="btn small">Send</button>
          </div>
        </div>

        <div class="panel" style="flex:1;min-height:0">
          <div class="panel-header"><span>Interactive</span>
            <div style="display:flex;gap:6px"><button id="predictBtn" class="btn small">Play & Predict</button><button id="openPoll" class="btn small">Quick Poll</button></div>
          </div>
          <div class="panel-body" style="min-height:80px">
            <div id="predict-panel"></div>
            <div id="poll-panel"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Fullscreen Controls -->
  <div id="fullscreen-controls">
    <button class="fullscreen-btn" id="fsTalkBtn" title="Hold to Talk">üéôÔ∏è</button>
    <button class="fullscreen-btn" id="fsReactionBtn" title="Send Reaction">‚ù§Ô∏è</button>
    <button class="fullscreen-btn" id="fsExitBtn" title="Exit Fullscreen">‚úï</button>
  </div>

  <!-- Firebase + Agora + YouTube -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="firebase-config.js"></script>
  <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.9.0.js"></script>
  <script src="agora.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    // Enhanced Watch Party Application
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();
    auth.signInAnonymously().catch(console.warn);

    const params = new URLSearchParams(location.search);
    const roomId = params.get('room');
    const isHost = params.get('host') === 'true';

    if (!roomId) {
      alert('Missing room id in URL. Use ?room=ROOMID&host=true to create a room');
      throw new Error('Missing roomId');
    }

    const roomRef = db.ref('rooms/' + roomId);
    const drawRef = roomRef.child('drawing');
    const reactionsRef = roomRef.child('reactions');
    const chatRef = roomRef.child('chat');
    const predictRef = roomRef.child('predicts');
    const pollsRef = roomRef.child('polls');

    // DOM Elements
    const html5video = document.getElementById('html5video');
    const ytContainer = document.getElementById('ytContainer');
    const overlayBlock = document.getElementById('overlay-block');
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    const reactionsBox = document.getElementById('reactions');
    const statusEl = document.getElementById('status');
    const roomInfo = document.getElementById('roomInfo');

    const speedSel = document.getElementById('speedSel');
    const pauseDiscussBtn = document.getElementById('pauseDiscussBtn');
    const toggleDrawBtn = document.getElementById('toggleDrawBtn');
    const clearDrawBtn = document.getElementById('clearDrawBtn');
    const spotlightBtn = document.getElementById('spotlightBtn');
    const focusBtn = document.getElementById('focusBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const holdTalkBtn = document.getElementById('holdTalkBtn');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatScroll = document.getElementById('chatScroll');
    const fsTalkBtn = document.getElementById('fsTalkBtn');
    const fsReactionBtn = document.getElementById('fsReactionBtn');
    const fsExitBtn = document.getElementById('fsExitBtn');

    // State variables
    let ready = false;
    let usingYT = false;
    let ytPlayer = null;
    let drawingEnabled = false;
    let drawing = false;
    let lastPos = null;
    let discussionOpen = false;
    let strokes = [];
    let agoraClient = null;
    let localAudioTrack = null;
    let isTalking = false;

    // Set status with loading indicator
    function setStatus(text, isError = false) {
      statusEl.innerHTML = isError ? `<span style="color:var(--error)">${text}</span>` : text;
    }

    // Canvas setup with high DPI support
    function fitCanvas() {
      const rect = document.getElementById('player-container').getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      redrawAllStrokes();
    }

    window.addEventListener('resize', fitCanvas);
    window.addEventListener('load', fitCanvas);

    // YouTube helpers
    function isYouTubeLink(url) {
      if (!url) return false;
      return /youtube\.com|youtu\.be|youtube-nocookie\.com/i.test(url);
    }

    function extractYoutubeID(url) {
      if (!url) return null;
      try {
        const u = new URL(url);
        if (u.hostname.includes('youtube.com') || u.hostname.includes('youtube-nocookie.com')) {
          const v = u.searchParams.get('v');
          if (v) return v;
          const parts = u.pathname.split('/');
          if (parts.includes('embed') && parts[parts.length - 1]) return parts[parts.length - 1];
        }
        if (u.hostname.includes('youtu.be')) {
          const parts = u.pathname.split('/');
          if (parts[1]) return parts[1];
        }
      } catch (e) {}
      const m = url.match(/[?&]v=([^&]+)/) || url.match(/youtu\.be\/([^?&]+)/);
      return m && m[1] ? m[1] : null;
    }

    function createYouTubePlayer(id, controls) {
      ytContainer.style.display = 'block';
      html5video.style.display = 'none';
      window._pendingYTCreate = window._pendingYTCreate || [];
      window._pendingYTCreate.push({ id, controls });
      if (window.YT && window.YT.Player && typeof window.onYouTubeIframeAPIReady === 'function') {
        window.onYouTubeIframeAPIReady();
      }
    }

    window.onYouTubeIframeAPIReady = function() {
      const list = window._pendingYTCreate || [];
      while (list.length) {
        const item = list.shift();
        if (ytPlayer) {
          try {
            ytPlayer.destroy();
          } catch (e) {}
        }
        ytPlayer = new YT.Player('ytPlayerIframe', {
          videoId: item.id,
          playerVars: {
            rel: 0,
            modestbranding: 1,
            playsinline: 1,
            iv_load_policy: 3,
            controls: item.controls ? 1 : 0,
            enablejsapi: 1
          },
          events: {
            onReady: () => {
              ready = true;
              fitCanvas();
              if (isHost) hostStart();
              else viewerStart();
            },
            onStateChange: (e) => {
              if (!isHost || !ytPlayer) return;
              const t = ytPlayer.getCurrentTime();
              if (e.data === YT.PlayerState.PLAYING) pushRoomState('play', t);
              if (e.data === YT.PlayerState.PAUSED) pushRoomState('pause', t);
            },
            onError: () => {
              setStatus('YouTube player error', true);
            }
          }
        });
      }
    };

    // Player control functions
    function playerGetTime() {
      try {
        return usingYT && ytPlayer ? ytPlayer.getCurrentTime() : (html5video.currentTime || 0);
      } catch (e) {
        return 0;
      }
    }

    function playerSeek(t) {
      try {
        if (usingYT && ytPlayer) ytPlayer.seekTo(t, true);
        else html5video.currentTime = t;
      } catch (e) {}
    }

    function playerPlay() {
      try {
        if (usingYT && ytPlayer) return ytPlayer.playVideo();
        else return html5video.play();
      } catch (e) {
        return Promise.reject(e);
      }
    }

    function playerPause() {
      try {
        if (usingYT && ytPlayer) return ytPlayer.pauseVideo();
        else return html5video.pause();
      } catch (e) {
        return Promise.reject(e);
      }
    }

    function playerIsPlaying() {
      try {
        if (usingYT && ytPlayer && ytPlayer.getPlayerState) {
          return ytPlayer.getPlayerState() === YT.PlayerState.PLAYING;
        }
        return (!html5video.paused && !html5video.seeking && html5video.readyState > 2);
      } catch (e) {
        return false;
      }
    }

    function playerSetRate(r) {
      try {
        if (usingYT && ytPlayer && ytPlayer.setPlaybackRate) ytPlayer.setPlaybackRate(r);
        else html5video.playbackRate = r;
      } catch (e) {}
    }

    // Load room
    roomRef.once('value').then(snap => {
      const data = snap.val();
      if (!data) {
        alert('Room not found');
        return;
      }
      if (!data.videoLink) {
        alert('No video link configured for room');
        return;
      }
      roomInfo.textContent = `Room: ${roomId}${isHost ? ' ‚Ä¢ Host' : ' ‚Ä¢ Viewer'}`;
      const link = data.videoLink;
      if (isYouTubeLink(link)) {
        usingYT = true;
        const id = extractYoutubeID(link);
        createYouTubePlayer(id, isHost);
      } else {
        usingYT = false;
        ytContainer.style.display = 'none';
        html5video.style.display = 'block';
        html5video.src = link;
        html5video.crossOrigin = 'anonymous';
        html5video.controls = !!isHost;
        html5video.preload = 'auto';
        
        // Add event listeners for HTML5 video
        html5video.addEventListener('loadedmetadata', () => {
          ready = true;
          fitCanvas();
          if (isHost) hostStart();
          else viewerStart();
        });
        
        html5video.addEventListener('error', (e) => {
          setStatus('Video loading error', true);
          console.error('Video error:', e);
        });
        
        html5video.addEventListener('waiting', () => {
          if (!isHost) setStatus('Buffering...');
        });
        
        html5video.addEventListener('canplay', () => {
          if (!isHost) setStatus('Watching ‚Äî synced to host');
        });
      }

      if (!isHost) {
        overlayBlock.classList.remove('hidden');
        overlayBlock.querySelector('.hint').textContent = 'Waiting for host ‚Äî controls disabled for viewers';
      }
    }).catch(err => {
      console.error(err);
      setStatus('Error loading room', true);
    });

    // Host state push
    function pushRoomState(status, time) {
      try {
        roomRef.update({
          status,
          currentTime: time,
          updatedAt: firebase.database.ServerValue.TIMESTAMP
        });
      } catch (e) {
        console.warn(e);
      }
    }

    // Enhanced sync constants
    let hostIntervalHandle = null;
    let lastHostUpdateMs = 0;
    let lastHardSeekMs = 0;
    const HARD_SEEK_COOLDOWN_MS = 3000;
    const HOST_UPDATE_INTERVAL_MS = 800;
    const VIEWER_ADJUST_THROTTLE_MS = 500;
    let lastViewerAdjustMs = 0;

    function computeHostEffectiveTime(hostTime, updatedAtMs) {
      const now = Date.now();
      const lagMs = Math.max(0, now - (updatedAtMs || now));
      return hostTime + (lagMs / 1000);
    }

    function computeNudgeRate(diffSeconds) {
      const maxNudge = 0.03;
      const sensitivity = 0.1;
      const rate = 1 + Math.max(-maxNudge, Math.min(maxNudge, diffSeconds * sensitivity));
      return rate;
    }

    function applyPlaybackRateForAll(rate) {
      try {
        playerSetRate(rate);
      } catch (e) {}
    }

    function hardSeekTo(timeSec) {
      const now = Date.now();
      if (now - lastHardSeekMs < HARD_SEEK_COOLDOWN_MS) return;
      lastHardSeekMs = now;
      try {
        playerSeek(timeSec);
      } catch (e) {}
    }

    // Host start
    function hostStart() {
      setStatus('Host ‚Äî you control playback');
      try {
        roomRef.update({
          status: playerIsPlaying() ? 'play' : 'pause',
          currentTime: playerGetTime(),
          updatedAt: firebase.database.ServerValue.TIMESTAMP
        });
      } catch (e) {}

      hostIntervalHandle = setInterval(() => {
        if (!ready) return;
        try {
          if (playerIsPlaying()) {
            const nowMs = Date.now();
            if (nowMs - lastHostUpdateMs >= HOST_UPDATE_INTERVAL_MS) {
              lastHostUpdateMs = nowMs;
              roomRef.update({
                currentTime: playerGetTime(),
                updatedAt: firebase.database.ServerValue.TIMESTAMP
              });
            }
          }
        } catch (e) {}
      }, HOST_UPDATE_INTERVAL_MS);

      // Host controls
      pauseDiscussBtn.addEventListener('click', () => {
        playerPause();
        roomRef.update({
          status: 'pause',
          discussionOpen: true
        });
      });

      toggleDrawBtn.addEventListener('click', () => {
        drawingEnabled = !drawingEnabled;
        toggleDrawBtn.textContent = drawingEnabled ? 'Drawing ON' : 'Draw';
        roomRef.update({ drawingEnabled });
      });

      clearDrawBtn.addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRef.remove().catch(() => {});
        strokes = [];
      });

      spotlightBtn.addEventListener('click', () => {
        roomRef.child('hostPowers').update({ spotlight: true });
        setTimeout(() => roomRef.child('hostPowers').update({ spotlight: false }), 5000);
      });

      focusBtn.addEventListener('click', () => {
        roomRef.child('hostPowers').update({ focusMode: true });
        setTimeout(() => roomRef.child('hostPowers').update({ focusMode: false }), 5000);
      });

      speedSel.addEventListener('change', e => {
        const sp = Number(e.target.value || 1);
        playerSetRate(sp);
        roomRef.child('hostPowers').update({ speed: sp });
      });

      fullscreenBtn.addEventListener('click', () => {
        const container = document.getElementById('player-container');
        if (container.requestFullscreen) container.requestFullscreen();
        else if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
        else if (container.mozRequestFullScreen) container.mozRequestFullScreen();
        else if (container.msRequestFullscreen) container.msRequestFullscreen();
      });

      document.getElementById('predictBtn').addEventListener('click', () => {
        const q = prompt('Enter prediction question');
        if (!q) return;
        const id = predictRef.push().key;
        predictRef.child(id).set({
          question: q,
          createdAt: firebase.database.ServerValue.TIMESTAMP,
          options: {},
          closed: false
        });
      });

      document.getElementById('openPoll').addEventListener('click', () => {
        const q = prompt('Poll question');
        if (!q) return;
        const id = pollsRef.push().key;
        pollsRef.child(id).set({
          q,
          options: {},
          createdAt: firebase.database.ServerValue.TIMESTAMP
        });
      });

      if (!usingYT) {
        html5video.addEventListener('play', () => pushRoomState('play', playerGetTime()));
        html5video.addEventListener('pause', () => pushRoomState('pause', playerGetTime()));
        html5video.addEventListener('seeked', () => pushRoomState(playerIsPlaying() ? 'play' : 'pause', playerGetTime()));
      }
    }

    // Viewer start
    function viewerStart() {
      setStatus('Viewer ‚Äî following host');

      function onBuffering() {
        roomRef.once('value').then(snap => {
          const data = snap.val() || {};
          const hostTime = data.currentTime || 0;
          const eff = computeHostEffectiveTime(hostTime, data.updatedAt || Date.now());
          hardSeekTo(eff);
          try {
            playerPlay();
          } catch (e) {}
        }).catch(() => {});
      }

      if (!usingYT) {
        html5video.addEventListener('waiting', onBuffering);
        html5video.addEventListener('stalled', onBuffering);
      }

      roomRef.on('value', snap => {
        const data = snap.val();
        if (!ready || !data) return;
        discussionOpen = !!data.discussionOpen;
        if (discussionOpen) setStatus('Discussion ‚Äî host paused to talk');
        else setStatus('Watching ‚Äî synced to host');

        // Host powers (speed)
        if (data.hostPowers && typeof data.hostPowers.speed !== 'undefined') {
          try {
            playerSetRate(Number(data.hostPowers.speed));
          } catch (e) {}
        }

        const hostTime = data.currentTime || 0;
        const hostEffective = computeHostEffectiveTime(hostTime, data.updatedAt || Date.now());

        let localT = 0;
        try {
          localT = playerGetTime();
        } catch (e) {}
        const diff = hostEffective - localT;
        const nowMs = Date.now();
        if (nowMs - lastViewerAdjustMs >= VIEWER_ADJUST_THROTTLE_MS) {
          lastViewerAdjustMs = nowMs;
          if (Math.abs(diff) > 5) {
            hardSeekTo(hostEffective);
            applyPlaybackRateForAll(1);
          } else if (Math.abs(diff) > 0.5) {
            const nudge = computeNudgeRate(diff);
            applyPlaybackRateForAll(nudge);
            try {
              const newT = localT + diff * 0.15;
              playerSeek(newT);
            } catch (e) {}
          } else {
            applyPlaybackRateForAll(1);
            if (Math.abs(diff) > 0.05) {
              try {
                playerSeek(localT + diff * 0.08);
              } catch (e) {}
            }
          }
        }

        if (data.status === 'play') {
          overlayBlock.classList.add('hidden');
          try {
            playerPlay();
          } catch (e) {}
        } else {
          if (!discussionOpen) overlayBlock.classList.remove('hidden');
          try {
            playerPause();
          } catch (e) {}
        }
      });

      // Protect viewer from local control attempts
      html5video.addEventListener('seeking', () => {
        roomRef.once('value').then(snap => {
          const d = snap.val() || {};
          const hostTime = d.currentTime || 0;
          playerSeek(hostTime);
        }).catch(() => {});
      });

      let stallCount = 0;
      if (!usingYT) {
        html5video.addEventListener('waiting', () => {
          stallCount++;
          if (stallCount >= 3) {
            roomRef.once('value').then(snap => {
              const data = snap.val() || {};
              const eff = computeHostEffectiveTime(data.currentTime || 0, data.updatedAt || Date.now());
              try {
                const src = html5video.currentSrc || html5video.src;
                html5video.pause();
                html5video.src = src;
                html5video.load();
                playerSeek(eff);
                playerPlay().catch(() => {});
                stallCount = 0;
              } catch (e) {}
            }).catch(() => {});
          }
        });
        html5video.addEventListener('playing', () => {
          stallCount = 0;
        });
      }
    }

    // Drawing functionality
    function enableDrawing() {
      canvas.style.pointerEvents = 'auto';
      canvas.addEventListener('mousedown', onDown);
      canvas.addEventListener('mousemove', onMove);
      canvas.addEventListener('mouseup', onUp);
      canvas.addEventListener('mouseleave', onUp);
      canvas.addEventListener('touchstart', onDown, { passive: false });
      canvas.addEventListener('touchmove', onMove, { passive: false });
      canvas.addEventListener('touchend', onUp);
    }

    function disableDrawing() {
      canvas.style.pointerEvents = 'none';
      canvas.removeEventListener('mousedown', onDown);
      canvas.removeEventListener('mousemove', onMove);
      canvas.removeEventListener('mouseup', onUp);
      canvas.removeEventListener('mouseleave', onUp);
      canvas.removeEventListener('touchstart', onDown);
      canvas.removeEventListener('touchmove', onMove);
      canvas.removeEventListener('touchend', onUp);
    }

    function getCanvasPos(e) {
      const r = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: (clientX - r.left),
        y: (clientY - r.top)
      };
    }

    function onDown(e) {
      if (!isHost || !drawingEnabled) return;
      e.preventDefault();
      drawing = true;
      lastPos = getCanvasPos(e);
    }

    function onMove(e) {
      if (!drawing || !isHost || !drawingEnabled) return;
      e.preventDefault();
      const pos = getCanvasPos(e);
      const color = '#fbbf24';
      const thickness = 3;
      ctx.strokeStyle = color;
      ctx.lineWidth = thickness;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastPos.x, lastPos.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      // push normalized
      try {
        drawRef.push({
          lx: lastPos.x / canvas.clientWidth,
          ly: lastPos.y / canvas.clientHeight,
          x: pos.x / canvas.clientWidth,
          y: pos.y / canvas.clientHeight,
          color,
          thickness
        });
      } catch (e) {}
      lastPos = pos;
    }

    function onUp() {
      drawing = false;
      lastPos = null;
    }

    // Listen to drawing data and rebuild strokes
    drawRef.on('value', snap => {
      const val = snap.val() || {};
      strokes = [];
      Object.keys(val).forEach(k => {
        const s = val[k];
        s._id = k;
        strokes.push(s);
      });
      redrawAllStrokes();
    });

    function redrawAllStrokes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const w = canvas.clientWidth,
        h = canvas.clientHeight;
      strokes.forEach(st => {
        try {
          ctx.strokeStyle = st.color || '#fbbf24';
          ctx.lineWidth = st.thickness || 3;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(st.lx * w, st.ly * h);
          ctx.lineTo(st.x * w, st.y * h);
          ctx.stroke();
        } catch (e) {}
      });
    }

    // Enable/disable drawing for host toggle from DB
    roomRef.child('drawingEnabled').on('value', s => {
      const on = !!s.val();
      drawingEnabled = on;
      if (on && isHost) enableDrawing();
      else disableDrawing();
      toggleDrawBtn.textContent = (on ? 'Drawing ON' : 'Draw');
    });

    // Reactions
    function showReactionBubble(emoji) {
      const el = document.createElement('div');
      el.className = 'reaction-bubble';
      el.textContent = emoji;
      reactionsBox.appendChild(el);
      setTimeout(() => el.remove(), 3000);
    }

    function emitReaction(emoji) {
      reactionsRef.push({
        emoji,
        at: firebase.database.ServerValue.TIMESTAMP
      });
    }

    document.querySelectorAll('.emoji-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const emoji = btn.getAttribute('data-emoji');
        emitReaction(emoji);
      });
    });

    reactionsRef.on('child_added', snap => {
      const v = snap.val() || {};
      if (v.emoji) showReactionBubble(v.emoji);
    });

    // Chat
    function appendChatMessage(msg) {
      const div = document.createElement('div');
      div.className = 'chat-msg';
      const meta = document.createElement('div');
      meta.className = 'chat-meta';
      const date = msg.at ? new Date(msg.at) : new Date();
      meta.textContent = `${msg.userLabel || 'Guest'} ‚Ä¢ ${date.toLocaleTimeString()}`;
      const body = document.createElement('div');
      body.textContent = msg.text;
      div.appendChild(meta);
      div.appendChild(body);
      chatMessages.appendChild(div);
      chatScroll.scrollTop = chatScroll.scrollHeight;
    }

    chatRef.limitToLast(150).on('child_added', snap => {
      const msg = snap.val();
      if (!msg) return;
      appendChatMessage(msg);
    });

    function sendChat() {
      const text = (chatInput.value || '').trim().slice(0, 1000);
      if (!text) return;
      const uid = (auth.currentUser && auth.currentUser.uid) || 'anon';
      chatRef.push({
        text,
        uid,
        userLabel: isHost ? 'Host' : 'Viewer',
        at: firebase.database.ServerValue.TIMESTAMP
      });
      chatInput.value = '';
    }

    chatSendBtn.addEventListener('click', sendChat);
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendChat();
      }
    });

    // Predicts & polls
    function renderPredicts(data) {
      const out = document.getElementById('predict-panel');
      out.innerHTML = '<strong>Predictions</strong><br/>';
      Object.keys(data || {}).forEach(id => {
        const p = data[id];
        const el = document.createElement('div');
        el.style.marginBottom = '6px';
        el.innerHTML = `<div><strong>${p.question}</strong></div>`;
        const btn = document.createElement('button');
        btn.textContent = 'Answer';
        btn.className = 'btn small grey';
        btn.onclick = () => {
          const ans = prompt('Your answer');
          if (!ans) return;
          predictRef.child(id).child('options').push({
            answer: ans,
            at: firebase.database.ServerValue.TIMESTAMP
          });
        };
        el.appendChild(btn);
        out.appendChild(el);
      });
    }

    function renderPolls(data) {
      const out = document.getElementById('poll-panel');
      out.innerHTML = '<strong>Polls</strong><br/>';
      Object.keys(data || {}).forEach(id => {
        const p = data[id];
        const el = document.createElement('div');
        el.style.marginBottom = '6px';
        el.innerHTML = `<div><strong>${p.q}</strong></div>`;
        const btn = document.createElement('button');
        btn.textContent = 'Vote';
        btn.className = 'btn small grey';
        btn.onclick = () => {
          const opt = prompt('Enter your vote');
          if (!opt) return;
          pollsRef.child(id).child('options').push({
            label: opt,
            at: firebase.database.ServerValue.TIMESTAMP
          });
        };
        el.appendChild(btn);
        out.appendChild(el);
      });
    }

    predictRef.on('value', s => renderPredicts(s.val() || {}));
    pollsRef.on('value', s => renderPolls(s.val() || {}));

    // Enhanced Agora Voice Integration
    function initAgoraVoiceEnhanced({ firebase, auth, roomId, isHost, holdTalkBtn, voiceStatus }) {
      // Check if agora.js is available
      if (typeof initAgoraVoice === 'undefined') {
        voiceStatus.innerHTML = '<span class="voice-error">Voice not available</span>';
        return;
      }
      
      // Initialize Agora with enhanced error handling
      try {
        initAgoraVoice({
          firebase,
          auth,
          roomId,
          isHost,
          holdTalkBtn,
          voiceStatus,
          onVoiceActive: () => {
            voiceStatus.innerHTML = '<span class="voice-active">Voice connected</span>';
            holdTalkBtn.textContent = 'Hold to Talk';
          },
          onVoiceError: (error) => {
            console.error('Agora error:', error);
            voiceStatus.innerHTML = `<span class="voice-error">Voice error: ${error.message || error}</span>`;
          }
        });
      } catch (error) {
        console.error('Failed to initialize Agora:', error);
        voiceStatus.innerHTML = '<span class="voice-error">Voice initialization failed</span>';
      }
    }

    // Initialize voice when auth state changes
    auth.onAuthStateChanged(user => {
      if (user) {
        initAgoraVoiceEnhanced({
          firebase,
          auth,
          roomId,
          isHost,
          holdTalkBtn,
          voiceStatus
        });
      }
    });

    // Fullscreen controls
    fsTalkBtn.addEventListener('mousedown', () => {
      if (holdTalkBtn) holdTalkBtn.dispatchEvent(new MouseEvent('mousedown'));
    });
    
    fsTalkBtn.addEventListener('mouseup', () => {
      if (holdTalkBtn) holdTalkBtn.dispatchEvent(new MouseEvent('mouseup'));
    });
    
    fsTalkBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (holdTalkBtn) holdTalkBtn.dispatchEvent(new Event('touchstart'));
    });
    
    fsTalkBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (holdTalkBtn) holdTalkBtn.dispatchEvent(new Event('touchend'));
    });

    fsReactionBtn.addEventListener('click', () => {
      emitReaction('‚ù§Ô∏è');
    });

    fsExitBtn.addEventListener('click', () => {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
      else if (document.msExitFullscreen) document.msExitFullscreen();
    });

    // Protect viewers from interacting with native controls
    if (!isHost) {
      try {
        html5video.controls = false;
        overlayBlock.classList.remove('hidden');
      } catch (e) {}
    }

    // Small UX protections
    document.addEventListener('contextmenu', e => {
      if (!isHost && e.target === html5video) e.preventDefault();
    });

    // Ensure fitCanvas is run once player sizes are known
    setTimeout(fitCanvas, 300);
    
    // Initialize mobile responsiveness
    function handleOrientationChange() {
      fitCanvas();
      // Additional mobile layout adjustments
      if (window.innerHeight > window.innerWidth) {
        // Portrait mode
        document.body.classList.remove('landscape');
      } else {
        // Landscape mode
        document.body.classList.add('landscape');
      }
    }
    
    window.addEventListener('orientationchange', handleOrientationChange);
    window.addEventListener('resize', handleOrientationChange);
    
    // Initial call
    handleOrientationChange();
  </script>
</body>
</html>
