<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Watch Party Room ‚Äî Improved</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#020617;--panel:#0f172a;--accent:#4f46e5;--text-main:#e5e7eb;--text-soft:#9ca3af}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial;color:var(--text-main);background:radial-gradient(circle at top left,#1d4ed8 0,#020617 35%,#000 100%)}
    
    /* Improved Top Bar */
    #topbar{display:flex;align-items:center;padding:10px 14px;gap:10px;background:linear-gradient(to right,rgba(15,23,42,0.9),rgba(15,23,42,0.7));backdrop-filter:blur(8px);border-bottom:1px solid rgba(148,163,184,0.12);z-index:120}
    #appTitle{font-weight:700;font-size:16px}
    #roomInfo{font-size:12px;color:var(--text-soft)}
    
    /* Main Controls Bar */
    #main-controls-bar{display:flex;align-items:center;gap:8px;padding:8px 14px;background:rgba(15,23,42,0.8);border-bottom:1px solid rgba(148,163,184,0.08);flex-wrap:wrap}
    .main-control-btn{padding:6px 12px;border-radius:999px;border:none;font-size:12px;cursor:pointer;background:rgba(15,23,42,0.9);color:var(--text-main);border:1px solid rgba(148,163,184,0.18);display:inline-flex;align-items:center;gap:6px;transition:all 0.2s}
    .main-control-btn:hover{background:rgba(30,41,59,0.9);transform:translateY(-1px)}
    .main-control-btn.active{background:var(--accent);color:#fff}
    
    /* Dropdown for additional controls */
    .dropdown{position:relative;display:inline-block}
    .dropdown-content{display:none;position:absolute;right:0;top:100%;background:rgba(15,23,42,0.95);backdrop-filter:blur(12px);min-width:180px;border-radius:12px;padding:8px;box-shadow:0 10px 25px rgba(0,0,0,0.5);border:1px solid rgba(148,163,184,0.15);z-index:1000;margin-top:4px}
    .dropdown:hover .dropdown-content{display:block}
    .dropdown-btn{width:100%;text-align:left;padding:8px 10px;margin:2px 0;border-radius:8px;border:none;background:transparent;color:var(--text-main);cursor:pointer;font-size:12px;display:flex;align-items:center;gap:8px}
    .dropdown-btn:hover{background:rgba(30,41,59,0.8)}
    
    .top-right{margin-left:auto;display:flex;align-items:center;gap:8px}
    .btn{padding:7px 10px;border-radius:999px;border:none;font-size:12px;cursor:pointer;background:var(--accent);color:#fff;display:inline-flex;align-items:center;gap:6px;transition:all 0.2s}
    .btn:hover{transform:translateY(-1px);box-shadow:0 4px 8px rgba(0,0,0,0.2)}
    .btn.grey{background:rgba(15,23,42,0.9);color:var(--text-main);border:1px solid rgba(148,163,184,0.18)}
    .btn.small{padding:4px 8px;font-size:11px}
    .emoji-btn{background:rgba(15,23,42,0.9);border:1px solid rgba(148,163,184,0.18)}

    .wrap{display:flex;gap:10px;padding:10px;flex:1;min-height:0;height:calc(100vh - 120px)}
    #left{flex:3;min-width:55%;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(15,23,42,0.8),rgba(15,23,42,0.95));border-radius:14px;padding:10px;box-shadow:0 20px 40px rgba(0,0,0,0.5);position:relative;min-height:0}
    #right{flex:2;min-width:40%;display:flex;flex-direction:column;gap:10px;min-height:0;overflow:auto;max-height:100%;position:relative}

    #player-container{position:relative;border-radius:12px;overflow:hidden;background:#000;flex:1;min-height:240px}
    video, #ytPlayerIframe{width:100%;height:100%;display:block;background:#000;object-fit:contain}

    /* overlay that blocks viewer controls when host paused */
    #overlay-block{position:absolute;inset:0;z-index:40;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.18);backdrop-filter:blur(2px);pointer-events:auto}
    #overlay-block.hidden{display:none}
    #overlay-block .hint{background:rgba(15,23,42,0.9);padding:8px 12px;border-radius:12px;border:1px solid rgba(148,163,184,0.18);font-size:13px;color:var(--text-soft)}

    canvas#drawingCanvas{position:absolute;inset:0;z-index:45;pointer-events:none}

    #reactions{position:absolute;right:12px;top:12px;z-index:60;display:flex;flex-direction:column;gap:8px;align-items:flex-end}
    .reaction-bubble{background:rgba(15,23,42,0.98);padding:6px 8px;border-radius:18px;box-shadow:0 8px 18px rgba(0,0,0,0.5);font-size:18px;animation:floatUp 3s ease forwards}
    @keyframes floatUp{0%{transform:translateY(0);opacity:1}80%{opacity:1}100%{transform:translateY(-60px);opacity:0}}

    .panel{background:rgba(15,23,42,0.92);border-radius:12px;padding:8px;border:1px solid rgba(148,163,184,0.08);display:flex;flex-direction:column}
    .panel-header{font-size:12px;font-weight:600;color:var(--text-soft);margin-bottom:6px;display:flex;align-items:center;justify-content:space-between}
    .panel-body{flex:1;overflow:auto;font-size:12px}

    /* Improved chat */
    #chatMessages{display:flex;flex-direction:column;gap:8px}
    .chat-msg{padding:10px 12px;border-radius:12px;background:rgba(2,6,23,0.6);border:1px solid rgba(148,163,184,0.06);position:relative}
    .chat-msg.host{background:rgba(79,70,229,0.15);border-color:rgba(79,70,229,0.3)}
    .chat-meta{font-size:11px;color:var(--text-soft);margin-bottom:4px;display:flex;justify-content:space-between}
    .chat-time{font-size:10px;opacity:0.7}

    /* Floating controls: ONLY shown in fullscreen (via :fullscreen) */
    .float-controls {
      position: absolute;
      z-index: 110;
      right: 16px;
      bottom: 18px;
      display:none;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      pointer-events:none;
    }
    .float-controls .btn, .float-controls .emoji-btn, .float-controls .talk-btn { pointer-events: auto; }
    .talk-btn {
      width:56px;height:56px;border-radius:999px;display:flex;align-items:center;justify-content:center;font-size:20px;background:linear-gradient(180deg,var(--accent),#3b3bff);box-shadow:0 10px 30px rgba(79,70,229,0.25);border:none;color:white;cursor:pointer;
      transition: all 0.2s;
    }
    .talk-btn.talking{background:linear-gradient(180deg,#ef4444,#dc2626);animation:pulse 1.5s infinite}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(239,68,68,0.7)}70%{box-shadow:0 0 0 10px rgba(239,68,68,0)}100%{box-shadow:0 0 0 0 rgba(239,68,68,0)}}
    .emoji-float { display:flex;gap:8px; }
    .emoji-float .emoji-btn { padding:8px 10px; font-size:18px; border-radius:12px; }

    /* show float controls only when fullscreen */
    :fullscreen .float-controls,
    :-webkit-full-screen .float-controls,
    :-ms-fullscreen .float-controls {
      display:flex;
      opacity: 1;
      pointer-events: auto;
    }

    /* Improved mobile landscape */
    @media (orientation: landscape) and (max-height: 500px) {
      .wrap { gap:8px; padding:6px; height:calc(100vh - 80px); }
      #right { position: absolute; right: 8px; top: 76px; width: 36%; max-height: calc(100vh - 92px); overflow-y: auto; background: rgba(15,23,42,0.95); padding: 6px; border-radius: 12px; z-index: 100; }
      #left { margin-right: 38%; min-height: 0; }
      #main-controls-bar { padding: 6px 10px; }
    }

    @media (max-width:900px){
      .wrap{flex-direction:column;padding:6px;gap:8px;height:calc(100vh - 140px)}
      #left{min-width:100%}
      #right{min-width:100%;max-height:40vh;overflow:auto;position:relative}
      .float-controls{right:10px;bottom:12px}
      #topbar{padding:8px}
      #main-controls-bar{gap:6px;padding:6px 10px}
    }
    
    /* Collapsible sections */
    .collapsible-header{display:flex;align-items:center;justify-content:space-between;cursor:pointer;user-select:none}
    .collapsible-content{overflow:hidden;transition:max-height 0.3s ease}
    .collapsible-content.collapsed{max-height:0}
    
    /* Improved poll/predict styling */
    .poll-option, .predict-option{margin:6px 0;padding:6px 8px;background:rgba(2,6,23,0.4);border-radius:8px;cursor:pointer;transition:background 0.2s}
    .poll-option:hover, .predict-option:hover{background:rgba(30,41,59,0.6)}
    .poll-option.selected{background:rgba(79,70,229,0.3);border:1px solid rgba(79,70,229,0.5)}
  </style>
</head>
<body>
  <div id="topbar">
    <div>
      <div id="appTitle">Watch Party</div>
      <div id="roomInfo"></div>
    </div>
    <div class="top-right" id="topRightControls">
      <button class="btn small emoji-btn" data-emoji="üòÇ">üòÇ</button>
      <button class="btn small emoji-btn" data-emoji="üò±">üò±</button>
      <button class="btn small emoji-btn" data-emoji="ü§®">ü§®</button>
      <button class="btn small emoji-btn" data-emoji="üëè">üëè</button>
    </div>
  </div>

  <!-- New Main Controls Bar -->
  <div id="main-controls-bar">
    <button id="playPauseBtn" class="main-control-btn">
      <span id="playPauseIcon">‚è∏Ô∏è</span> <span id="playPauseText">Pause</span>
    </button>
    <button id="syncBtn" class="main-control-btn">üîÑ Sync</button>
    <button class="main-control-btn emoji-btn" data-emoji="üòÇ">üòÇ</button>
    <button class="main-control-btn emoji-btn" data-emoji="üëè">üëè</button>
    <button class="main-control-btn emoji-btn" data-emoji="üî•">üî•</button>
    
    <!-- Chat toggle -->
    <button id="chatToggle" class="main-control-btn">üí¨ Chat</button>
    
    <!-- Talk toggle -->
    <button id="talkToggle" class="main-control-btn">üéô Talk</button>
    
    <!-- Dropdown for additional controls -->
    <div class="dropdown">
      <button class="main-control-btn">‚öôÔ∏è More</button>
      <div class="dropdown-content">
        <button id="toggleDrawBtn" class="dropdown-btn">üñä Draw</button>
        <button id="clearDrawBtn" class="dropdown-btn">üóë Clear Draw</button>
        <button id="spotlightBtn" class="dropdown-btn">üî¶ Spotlight</button>
        <button id="focusBtn" class="dropdown-btn">üéØ Focus Mode</button>
        <button id="fullscreenBtn" class="dropdown-btn">üì∫ Fullscreen</button>
        <hr style="border:none;height:1px;background:rgba(148,163,184,0.2);margin:4px 0">
        <button id="predictBtn" class="dropdown-btn">üîÆ Play & Predict</button>
        <button id="openPoll" class="dropdown-btn">üìä Quick Poll</button>
        <div style="padding:8px 10px;display:flex;align-items:center;gap:6px">
          <span style="font-size:11px">Speed:</span>
          <select id="speedSel" style="background:rgba(15,23,42,0.9);color:var(--text-main);border-radius:999px;border:1px solid rgba(148,163,184,0.2);padding:4px 6px;font-size:11px;flex:1">
            <option value="0.5">0.5x</option>
            <option value="0.75">0.75x</option>
            <option value="1" selected>1x</option>
            <option value="1.25">1.25x</option>
            <option value="1.5">1.5x</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div id="left">
      <div id="player-container">
        <video id="html5video" playsinline preload="metadata"></video>
        <div id="ytContainer" style="display:none;width:100%;height:100%"><div id="ytPlayerIframe"></div></div>
        <canvas id="drawingCanvas"></canvas>
        <div id="overlay-block" class="hidden"><div class="hint">You're viewing ‚Äî host controls playback</div></div>
        <div id="reactions"></div>

        <!-- Floating controls (ONLY visible in fullscreen) -->
        <div class="float-controls" id="floatControls" aria-hidden="true">
          <div class="emoji-float">
            <button class="emoji-btn" data-emoji="üòÇ">üòÇ</button>
            <button class="emoji-btn" data-emoji="üëè">üëè</button>
            <button class="emoji-btn" data-emoji="üî•">üî•</button>
          </div>
          <button id="talkFloatingBtn" class="talk-btn" title="Hold to talk">üéô</button>
        </div>
      </div>
      <div id="status" style="margin-top:8px;font-size:13px;color:#a5b4fc"></div>
    </div>

    <div id="right">
      <!-- Chat Panel -->
      <div class="panel" style="flex:1;min-height:0;display:flex;flex-direction:column">
        <div class="panel-header collapsible-header">
          <span>Party Chat</span>
          <span>‚ñº</span>
        </div>
        <div class="panel-body collapsible-content" id="chatScroll" style="padding:6px;min-height:80px;overflow:auto">
          <div id="chatMessages"></div>
        </div>
        <div id="chatInputRow" style="display:flex;gap:6px;margin-top:8px">
          <input id="chatInput" placeholder="Type a message..." style="flex:1;padding:8px;border-radius:999px;border:1px solid rgba(148,163,184,0.08);background:rgba(2,6,23,0.6);color:var(--text-main)" />
          <button id="chatSendBtn" class="btn small">Send</button>
        </div>
      </div>

      <!-- Voice Panel -->
      <div class="panel" style="flex:0 0 auto">
        <div class="panel-header collapsible-header">
          <span>Voice Talk</span>
          <span>‚ñº</span>
        </div>
        <div class="panel-body collapsible-content" style="display:flex;flex-direction:column;gap:6px">
          <button id="holdTalkBtn" class="btn grey">Hold to Talk</button>
          <div id="voiceStatus">Initializing voice...</div>
        </div>
      </div>

      <!-- Interactive Panel -->
      <div class="panel" style="flex:1;min-height:0">
        <div class="panel-header collapsible-header">
          <span>Interactive</span>
          <span>‚ñº</span>
        </div>
        <div class="panel-body collapsible-content" style="min-height:80px">
          <div id="predict-panel"></div>
          <div id="poll-panel"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase + Agora + YouTube (same external scripts expected) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="firebase-config.js"></script>
  <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.9.0.js"></script>
  <script src="agora.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    // --- Basic init & DOM refs ---
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();
    auth.signInAnonymously().catch(console.warn);

    const params = new URLSearchParams(location.search);
    const roomId = params.get('room');
    const isHost = params.get('host') === 'true';

    if (!roomId) {
      alert('Missing room id in URL. Use ?room=ROOMID&host=true to create a room');
      throw new Error('Missing roomId');
    }

    const roomRef = db.ref('rooms/' + roomId);
    const drawRef = roomRef.child('drawing');
    const reactionsRef = roomRef.child('reactions');
    const chatRef = roomRef.child('chat');
    const predictRef = roomRef.child('predicts');
    const pollsRef = roomRef.child('polls');

    const html5video = document.getElementById('html5video');
    const ytContainer = document.getElementById('ytContainer');
    const overlayBlock = document.getElementById('overlay-block');
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    const reactionsBox = document.getElementById('reactions');
    const statusEl = document.getElementById('status');
    const roomInfo = document.getElementById('roomInfo');

    // New UI elements
    const playPauseBtn = document.getElementById('playPauseBtn');
    const playPauseIcon = document.getElementById('playPauseIcon');
    const playPauseText = document.getElementById('playPauseText');
    const syncBtn = document.getElementById('syncBtn');
    const chatToggle = document.getElementById('chatToggle');
    const talkToggle = document.getElementById('talkToggle');
    
    // Existing elements
    const speedSel = document.getElementById('speedSel');
    const toggleDrawBtn = document.getElementById('toggleDrawBtn');
    const clearDrawBtn = document.getElementById('clearDrawBtn');
    const spotlightBtn = document.getElementById('spotlightBtn');
    const focusBtn = document.getElementById('focusBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const holdTalkBtn = document.getElementById('holdTalkBtn');
    const talkFloatingBtn = document.getElementById('talkFloatingBtn');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatScroll = document.getElementById('chatScroll');
    const floatControls = document.getElementById('floatControls');

    let ready = false;
    usingYT = false;
    let ytPlayer = null;
    let drawingEnabled = false;
    let drawing = false;
    let lastPos = null;
    let discussionOpen = false;

    // keep normalized strokes in memory so we can redraw on resize
    let strokes = [];

    // Agora wrapper holder
    let agoraSession = null;
    let agoraLocalMicOn = false;

    function setStatus(text){statusEl.textContent = text}
    function setVoiceStatus(text){ voiceStatus.textContent = text; console.log('[VoiceStatus]', text); }

    // --- canvas sizing (supports high DPI) ---
    function fitCanvas(){
      const rect = document.getElementById('player-container').getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      redrawAllStrokes();
    }
    window.addEventListener('resize', fitCanvas);
    window.addEventListener('load', fitCanvas);

    // --- YouTube helpers ---
    function isYouTubeLink(url){ if(!url) return false; return /youtube\.com|youtu\.be|youtube-nocookie\.com/i.test(url) }
    function extractYoutubeID(url){ if(!url) return null; try{const u=new URL(url); if(u.hostname.includes('youtube.com')||u.hostname.includes('youtube-nocookie.com')){const v=u.searchParams.get('v'); if(v) return v; const parts=u.pathname.split('/'); if(parts.includes('embed')&&parts[parts.length-1]) return parts[parts.length-1]} if(u.hostname.includes('youtu.be')){const parts=u.pathname.split('/'); if(parts[1]) return parts[1]} }catch(e){} const m = url.match(/[?&]v=([^&]+)/) || url.match(/youtu\.be\/([^?&]+)/); return m && m[1] ? m[1] : null }

    function createYouTubePlayer(id, controls){
      ytContainer.style.display = 'block';
      html5video.style.display = 'none';
      window._pendingYTCreate = window._pendingYTCreate || [];
      window._pendingYTCreate.push({id,controls});
      if(window.YT && window.YT.Player && typeof window.onYouTubeIframeAPIReady === 'function'){
        window.onYouTubeIframeAPIReady();
      }
    }

    // ensure single global callback
    window.onYouTubeIframeAPIReady = function(){
      const list = window._pendingYTCreate || [];
      while(list.length){
        const item = list.shift();
        if(ytPlayer){ try{ ytPlayer.destroy(); }catch(e){} }
        ytPlayer = new YT.Player('ytPlayerIframe',{
          videoId:item.id,
          playerVars:{rel:0,modestbranding:1,playsinline:1,iv_load_policy:3,controls: item.controls?1:0},
          events:{
            onReady:()=>{ready=true;fitCanvas();if(isHost) hostStart();else viewerStart();},
            onStateChange:(e)=>{ if(!isHost || !ytPlayer) return; const t = ytPlayer.getCurrentTime(); if(e.data===YT.PlayerState.PLAYING) pushRoomState('play',t); if(e.data===YT.PlayerState.PAUSED) pushRoomState('pause',t); }
          }
        });
      }
    }

    function playerGetTime(){ try{ return usingYT && ytPlayer ? ytPlayer.getCurrentTime() : (html5video.currentTime || 0) }catch(e){return 0} }
    function playerSeek(t){ try{ if(usingYT && ytPlayer) ytPlayer.seekTo(t,true); else html5video.currentTime = t }catch(e){} }
    function playerPlay(){ try{ if(usingYT && ytPlayer) return ytPlayer.playVideo(); else return html5video.play(); }catch(e){} }
    function playerPause(){ try{ if(usingYT && ytPlayer) return ytPlayer.pause(); else return html5video.pause(); }catch(e){} }
    function playerIsPlaying(){ try{ if(usingYT && ytPlayer && ytPlayer.getPlayerState) return ytPlayer.getPlayerState()===YT.PlayerState.PLAYING; return (!html5video.paused && !html5video.seeking); }catch(e){return false} }
    function playerSetRate(r){ try{ if(usingYT && ytPlayer && ytPlayer.setPlaybackRate) ytPlayer.setPlaybackRate(r); else html5video.playbackRate = r }catch(e){} }

    // --- load room ---
    roomRef.once('value').then(snap=>{
      const data = snap.val();
      if(!data){alert('Room not found');return}
      if(!data.videoLink){alert('No video link configured for room');return}
      roomInfo.textContent = `Room: ${roomId}${isHost? ' ‚Ä¢ Host':' ‚Ä¢ Viewer'}`;
      const link = data.videoLink;
      if(isYouTubeLink(link)){
        usingYT = true; const id = extractYoutubeID(link);
        createYouTubePlayer(id, isHost);
      } else {
        usingYT = false; ytContainer.style.display = 'none'; html5video.style.display = 'block';
        html5video.src = link; html5video.crossOrigin = 'anonymous';
        html5video.preload = 'auto';
        html5video.controls = !!isHost;
        html5video.addEventListener('loadedmetadata', ()=>{ready=true;fitCanvas(); if(isHost) hostStart(); else viewerStart();});
      }

      if(!isHost){ overlayBlock.classList.remove('hidden'); overlayBlock.querySelector('.hint').textContent = 'Waiting for host ‚Äî controls disabled for viewers'; }
    }).catch(err=>{console.error(err);setStatus('Error loading room')});

    // --- host state push ---
    function pushRoomState(status, time){
      try{ roomRef.update({status,currentTime:time,updatedAt:firebase.database.ServerValue.TIMESTAMP}); }catch(e){console.warn(e)}
    }

    // --- IMPROVED SYNC LOGIC ---
    let hostIntervalHandle = null; 
    let lastHostUpdateMs = 0; 
    let lastHardSeekMs = 0;
    let lastViewerAdjustMs = 0;
    
    // Tuned sync parameters
    const HARD_SEEK_COOLDOWN_MS = 3000;
    const HOST_UPDATE_INTERVAL_MS = 800;
    const VIEWER_ADJUST_THROTTLE_MS = 500;
    const MAX_TIME_DRIFT = 0.3; // 300ms max drift
    const BUFFER_RECOVERY_DELAY = 1000;

    function computeHostEffectiveTime(hostTime, updatedAtMs){ 
      const now = Date.now(); 
      const lagMs = Math.max(0, now - (updatedAtMs || now)); 
      return hostTime + (lagMs/1000); 
    }
    
    function computeNudgeRate(diffSeconds){ 
      const maxNudge = 0.02; 
      const sensitivity = 0.15; 
      return 1 + Math.max(-maxNudge, Math.min(maxNudge, diffSeconds * sensitivity)); 
    }
    
    function applyPlaybackRateForAll(rate){ 
      try{ playerSetRate(rate); }catch(e){} 
    }
    
    function hardSeekTo(timeSec){ 
      const now = Date.now(); 
      if(now - lastHardSeekMs < HARD_SEEK_COOLDOWN_MS) return; 
      lastHardSeekMs = now; 
      try{ 
        playerSeek(timeSec);
        console.log(`Hard seek to ${timeSec}s`);
      }catch(e){} 
    }

    // --- host start ---
    function hostStart(){ 
      setStatus('Host ‚Äî you control playback');
      
      // Initialize room state
      try{ 
        roomRef.update({
          status: playerIsPlaying()? 'play':'pause', 
          currentTime: playerGetTime(), 
          updatedAt: firebase.database.ServerValue.TIMESTAMP
        }); 
      }catch(e){}

      // Update play/pause button state
      updatePlayPauseButton();

      // Host update interval
      hostIntervalHandle = setInterval(()=>{ 
        if(!ready) return; 
        try{ 
          if(playerIsPlaying()){ 
            const nowMs = Date.now(); 
            if(nowMs - lastHostUpdateMs >= HOST_UPDATE_INTERVAL_MS){ 
              lastHostUpdateMs = nowMs; 
              roomRef.update({
                currentTime: playerGetTime(), 
                updatedAt: firebase.database.ServerValue.TIMESTAMP
              }); 
            } 
          } 
        }catch(e){} 
      }, HOST_UPDATE_INTERVAL_MS);

      // Host controls
      playPauseBtn.addEventListener('click', ()=>{ 
        if(playerIsPlaying()) {
          playerPause(); 
          roomRef.update({status:'pause'});
        } else {
          playerPlay(); 
          roomRef.update({status:'play', currentTime: playerGetTime()});
        }
        updatePlayPauseButton();
      });
      
      syncBtn.addEventListener('click', ()=>{
        roomRef.update({
          currentTime: playerGetTime(),
          updatedAt: firebase.database.ServerValue.TIMESTAMP
        });
        setStatus('Sync requested');
      });
      
      toggleDrawBtn.addEventListener('click', ()=>{ 
        drawingEnabled = !drawingEnabled; 
        toggleDrawBtn.textContent = drawingEnabled? 'Drawing ON':'Draw'; 
        roomRef.update({drawingEnabled}); 
      });
      
      clearDrawBtn.addEventListener('click', ()=>{ 
        ctx.clearRect(0,0,canvas.width,canvas.height); 
        drawRef.remove().catch(()=>{}); 
        strokes=[]; 
      });
      
      spotlightBtn.addEventListener('click', ()=>{ 
        roomRef.child('hostPowers').update({spotlight:true}); 
        setTimeout(()=>roomRef.child('hostPowers').update({spotlight:false}),5000); 
      });
      
      focusBtn.addEventListener('click', ()=>{ 
        roomRef.child('hostPowers').update({focusMode:true}); 
        setTimeout(()=>roomRef.child('hostPowers').update({focusMode:false}),5000); 
      });
      
      speedSel.addEventListener('change', e=>{ 
        const sp = Number(e.target.value||1); 
        playerSetRate(sp); 
        roomRef.child('hostPowers').update({speed:sp}); 
      });
      
      fullscreenBtn.addEventListener('click', ()=>{ 
        const container = document.getElementById('player-container'); 
        if(container.requestFullscreen) container.requestFullscreen(); 
      });

      if(!usingYT){
        html5video.addEventListener('play', ()=> {
          pushRoomState('play', playerGetTime());
          updatePlayPauseButton();
        });
        html5video.addEventListener('pause', ()=> {
          pushRoomState('pause', playerGetTime());
          updatePlayPauseButton();
        });
        html5video.addEventListener('seeked', ()=> {
          pushRoomState(playerIsPlaying()? 'play':'pause', playerGetTime());
        });
      }
      
      document.getElementById('predictBtn').addEventListener('click', ()=>{ 
        const q = prompt('Enter prediction question'); 
        if(!q) return; 
        const id = predictRef.push().key; 
        predictRef.child(id).set({
          question:q,
          createdAt:firebase.database.ServerValue.TIMESTAMP,
          options:{},
          closed:false
        }); 
      });
      
      document.getElementById('openPoll').addEventListener('click', ()=>{ 
        const q=prompt('Poll question'); 
        if(!q) return; 
        const id = pollsRef.push().key; 
        pollsRef.child(id).set({
          q,
          options:{},
          createdAt:firebase.database.ServerValue.TIMESTAMP
        }); 
      });
    }

    function updatePlayPauseButton() {
      const playing = playerIsPlaying();
      playPauseIcon.textContent = playing ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
      playPauseText.textContent = playing ? 'Pause' : 'Play';
    }

    // --- IMPROVED viewer start with better sync ---
    function viewerStart(){ 
      setStatus('Viewer ‚Äî following host');
      
      let bufferRecoveryTimer = null;
      let consecutiveStalls = 0;
      
      function onBuffering(){
        if(bufferRecoveryTimer) return;
        consecutiveStalls++;
        
        bufferRecoveryTimer = setTimeout(()=>{
          roomRef.once('value').then(snap=>{
            const data = snap.val()||{};
            const hostTime = data.currentTime||0;
            const eff = computeHostEffectiveTime(hostTime, data.updatedAt||Date.now());
            
            // Gentle recovery with backoff based on consecutive stalls
            const backoff = Math.min(2, consecutiveStalls * 0.3);
            try{
              playerPause();
              playerSeek(Math.max(0, eff - backoff));
              setTimeout(() => {
                playerPlay().catch(()=>{});
              }, 300);
            }catch(e){}
          }).catch(()=>{});
          bufferRecoveryTimer = null;
        }, BUFFER_RECOVERY_DELAY);
      }

      if(!usingYT){ 
        html5video.addEventListener('waiting', onBuffering); 
        html5video.addEventListener('stalled', onBuffering);
        html5video.addEventListener('playing', ()=>{ consecutiveStalls = 0; });
      }

      roomRef.on('value', snap=>{
        const data = snap.val();
        if(!ready || !data) return;
        
        discussionOpen = !!data.discussionOpen;
        if(discussionOpen) {
          setStatus('Discussion ‚Äî host paused to talk'); 
        } else {
          setStatus('Watching ‚Äî synced to host');
        }

        // Apply host powers (speed)
        if(data.hostPowers && typeof data.hostPowers.speed !== 'undefined'){ 
          try{ playerSetRate(Number(data.hostPowers.speed)); }catch(e){} 
        }

        const hostTime = data.currentTime || 0;
        const hostEffective = computeHostEffectiveTime(hostTime, data.updatedAt || Date.now());

        let localT = 0; 
        try{ localT = playerGetTime(); }catch(e){}
        
        const diff = hostEffective - localT;
        const absDiff = Math.abs(diff);
        const nowMs = Date.now();
        
        if(nowMs - lastViewerAdjustMs >= VIEWER_ADJUST_THROTTLE_MS){
          lastViewerAdjustMs = nowMs;
          
          // Only hard seek for large drift (>1.5s) to avoid cracking
          if(absDiff > 1.5){
            hardSeekTo(hostEffective);
            applyPlaybackRateForAll(1);
          } 
          // Use rate adjustment for medium drift
          else if(absDiff > MAX_TIME_DRIFT){
            const nudge = computeNudgeRate(diff);
            applyPlaybackRateForAll(nudge);
            // Gentle seek correction
            try{ 
              const seekCorrection = localT + (diff * 0.1);
              playerSeek(seekCorrection); 
            }catch(e){}
          } 
          // Small drift - just adjust playback rate slightly
          else if(absDiff > 0.1){
            const nudge = computeNudgeRate(diff);
            applyPlaybackRateForAll(nudge);
          }
          // Very close - use normal rate
          else {
            applyPlaybackRateForAll(1);
          }
        }

        // Apply play/pause immediately
        if(data.status === 'play'){
          overlayBlock.classList.add('hidden');
          try{ playerPlay(); }catch(e){}
        } else {
          if(!discussionOpen) overlayBlock.classList.remove('hidden');
          try{ playerPause(); }catch(e){}
        }
      });

      // Protect viewer from local control attempts
      html5video.addEventListener('seeking', ()=>{
        roomRef.once('value').then(snap=>{
          const d = snap.val()||{};
          const hostTime = d.currentTime||0;
          playerSeek(hostTime);
        }).catch(()=>{});
      });

      // Sync button for viewers
      syncBtn.addEventListener('click', ()=>{
        roomRef.once('value').then(snap=>{
          const data = snap.val()||{};
          const hostTime = data.currentTime||0;
          hardSeekTo(hostTime);
          setStatus('Manual sync requested');
        });
      });
    }

    // ------------- DRAWING -------------
    function enableDrawing(){ 
      canvas.style.pointerEvents = 'auto'; 
      canvas.addEventListener('mousedown', onDown); 
      canvas.addEventListener('mousemove', onMove); 
      canvas.addEventListener('mouseup', onUp); 
      canvas.addEventListener('mouseleave', onUp); 
      canvas.addEventListener('touchstart', onDown,{passive:false}); 
      canvas.addEventListener('touchmove', onMove,{passive:false}); 
      canvas.addEventListener('touchend', onUp); 
    }
    
    function disableDrawing(){ 
      canvas.style.pointerEvents = 'none'; 
      canvas.removeEventListener('mousedown', onDown); 
      canvas.removeEventListener('mousemove', onMove); 
      canvas.removeEventListener('mouseup', onUp); 
      canvas.removeEventListener('mouseleave', onUp); 
      canvas.removeEventListener('touchstart', onDown); 
      canvas.removeEventListener('touchmove', onMove); 
      canvas.removeEventListener('touchend', onUp); 
    }
    
    function getCanvasPos(e){ 
      const r = canvas.getBoundingClientRect(); 
      const clientX = e.touches ? e.touches[0].clientX : e.clientX; 
      const clientY = e.touches ? e.touches[0].clientY : e.clientY; 
      return {
        x: (clientX - r.left), 
        y: (clientY - r.top)
      }; 
    }
    
    function onDown(e){ 
      if(!isHost || !drawingEnabled) return; 
      e.preventDefault(); 
      drawing=true; 
      lastPos = getCanvasPos(e); 
    }
    
    function onMove(e){ 
      if(!drawing || !isHost || !drawingEnabled) return; 
      e.preventDefault(); 
      const pos = getCanvasPos(e); 
      const color = '#fbbf24'; 
      const thickness = 3; 
      ctx.strokeStyle = color; 
      ctx.lineWidth = thickness; 
      ctx.lineCap = 'round'; 
      ctx.beginPath(); 
      ctx.moveTo(lastPos.x,lastPos.y); 
      ctx.lineTo(pos.x,pos.y); 
      ctx.stroke(); 
      try{ 
        drawRef.push({
          lx: lastPos.x / canvas.clientWidth, 
          ly: lastPos.y / canvas.clientHeight, 
          x: pos.x / canvas.clientWidth, 
          y: pos.y / canvas.clientHeight, 
          color, 
          thickness
        }); 
      }catch(e){} 
      lastPos = pos; 
    }
    
    function onUp(){ 
      drawing=false; 
      lastPos=null; 
    }

    drawRef.on('value', snap=>{
      const val = snap.val() || {};
      strokes = [];
      Object.keys(val).forEach(k=>{ const s = val[k]; s._id = k; strokes.push(s); });
      redrawAllStrokes();
    });

    function redrawAllStrokes(){ 
      ctx.clearRect(0,0,canvas.width,canvas.height); 
      const w = canvas.clientWidth, h = canvas.clientHeight; 
      strokes.forEach(st=>{ 
        try{ 
          ctx.strokeStyle = st.color || '#fbbf24'; 
          ctx.lineWidth = st.thickness || 3; 
          ctx.lineCap='round'; 
          ctx.beginPath(); 
          ctx.moveTo(st.lx*w, st.ly*h); 
          ctx.lineTo(st.x*w, st.y*h); 
          ctx.stroke(); 
        }catch(e){} 
      }); 
    }

    roomRef.child('drawingEnabled').on('value', s=>{ 
      const on = !!s.val(); 
      drawingEnabled = on; 
      if(on && isHost) enableDrawing(); 
      else disableDrawing(); 
      toggleDrawBtn.textContent = (on? 'Drawing ON':'Draw'); 
    });

    // --- reactions ---
    function showReactionBubble(emoji){ 
      const el = document.createElement('div'); 
      el.className='reaction-bubble'; 
      el.textContent = emoji; 
      reactionsBox.appendChild(el); 
      setTimeout(()=>el.remove(),3000); 
    }
    
    function emitReaction(emoji){ 
      reactionsRef.push({
        emoji,
        at:firebase.database.ServerValue.TIMESTAMP
      }); 
    }
    
    document.querySelectorAll('.emoji-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{ 
        const emoji = btn.getAttribute('data-emoji') || btn.textContent; 
        emitReaction(emoji); 
      });
    });
    
    reactionsRef.on('child_added', snap=>{ 
      const v = snap.val()||{}; 
      if(v.emoji) showReactionBubble(v.emoji); 
    });

    // floating emoji buttons on video - mirror the above
    document.querySelectorAll('.float-controls .emoji-btn').forEach(btn=>{
      btn.addEventListener('click', e=>{ 
        emitReaction(btn.dataset.emoji || btn.textContent); 
      });
    });

    // --- IMPROVED chat ---
    function appendChatMessage(msg){ 
      const div = document.createElement('div'); 
      div.className = `chat-msg ${msg.userLabel === 'Host' ? 'host' : ''}`;
      
      const meta = document.createElement('div'); 
      meta.className='chat-meta'; 
      
      const date = msg.at ? new Date(msg.at) : new Date();
      const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      meta.innerHTML = `
        <span>${msg.userLabel||'Guest'}</span>
        <span class="chat-time">${timeStr}</span>
      `;
      
      const body = document.createElement('div'); 
      body.textContent = msg.text; 
      
      div.appendChild(meta); 
      div.appendChild(body); 
      chatMessages.appendChild(div); 
      
      // Auto scroll to bottom
      chatScroll.scrollTop = chatScroll.scrollHeight;
    }
    
    chatRef.limitToLast(150).on('child_added', snap=>{ 
      const msg = snap.val(); 
      if(!msg) return; 
      appendChatMessage(msg); 
    });
    
    function sendChat(){ 
      const text = (chatInput.value||'').trim().slice(0,1000); 
      if(!text) return; 
      const uid = (auth.currentUser && auth.currentUser.uid) || 'anon'; 
      chatRef.push({
        text,
        uid,
        userLabel: isHost ? 'Host' : 'Viewer',
        at: firebase.database.ServerValue.TIMESTAMP
      }); 
      chatInput.value=''; 
    }
    
    chatSendBtn.addEventListener('click', sendChat); 
    chatInput.addEventListener('keydown', (e)=>{ 
      if(e.key==='Enter'){ 
        e.preventDefault(); 
        sendChat(); 
      } 
    });

    // --- predicts & polls (improved) ---
    function renderPredicts(data){ 
      const out = document.getElementById('predict-panel'); 
      out.innerHTML = '<div style="margin-bottom:8px;font-weight:600">Predictions</div>'; 
      Object.keys(data||{}).forEach(id=>{ 
        const p = data[id]; 
        const el = document.createElement('div'); 
        el.style.marginBottom='10px'; 
        el.style.padding='8px';
        el.style.background='rgba(2,6,23,0.4)';
        el.style.borderRadius='8px';
        
        el.innerHTML = `
          <div style="font-weight:500;margin-bottom:6px">${p.question}</div>
          <button class="predict-option" data-id="${id}">Make Prediction</button>
        `;
        
        out.appendChild(el); 
      }); 
    }
    
    function renderPolls(data){ 
      const out = document.getElementById('poll-panel'); 
      out.innerHTML = '<div style="margin-bottom:8px;font-weight:600">Polls</div>'; 
      Object.keys(data||{}).forEach(id=>{ 
        const p=data[id]; 
        const el=document.createElement('div'); 
        el.style.marginBottom='10px';
        el.style.padding='8px';
        el.style.background='rgba(2,6,23,0.4)';
        el.style.borderRadius='8px';
        
        el.innerHTML = `
          <div style="font-weight:500;margin-bottom:6px">${p.q}</div>
          <button class="poll-option" data-id="${id}">Vote in Poll</button>
        `;
        
        out.appendChild(el); 
      }); 
      
      // Add event listeners for poll options
      document.querySelectorAll('.poll-option').forEach(btn => {
        btn.addEventListener('click', function() {
          const pollId = this.getAttribute('data-id');
          const answer = prompt('Enter your vote:');
          if(!answer) return;
          pollsRef.child(pollId).child('options').push({
            label: answer,
            at: firebase.database.ServerValue.TIMESTAMP
          });
        });
      });
      
      // Add event listeners for predict options
      document.querySelectorAll('.predict-option').forEach(btn => {
        btn.addEventListener('click', function() {
          const predictId = this.getAttribute('data-id');
          const answer = prompt('Your prediction:');
          if(!answer) return;
          predictRef.child(predictId).child('options').push({
            answer: answer,
            at: firebase.database.ServerValue.TIMESTAMP
          });
        });
      });
    }
    
    predictRef.on('value', s=>renderPredicts(s.val()||{})); 
    pollsRef.on('value', s=>renderPolls(s.val()||{}));

    // --- IMPROVED voice (agora) integration ---
    function tryAttachAgoraSession(session) {
      if(!session) return false;
      agoraSession = session;
      console.log('agora session attached', session);
      
      try {
        if(typeof session.on === 'function') {
          session.on('user-published', (uid, mediaType) => {
            console.log('agora user-published', uid, mediaType);
            setVoiceStatus('Remote user published: ' + uid);
            
            if(typeof session.subscribe === 'function') {
              session.subscribe(uid, mediaType).then(remoteTrack => {
                if(mediaType === 'audio' && remoteTrack && typeof remoteTrack.play === 'function') {
                  const audio = document.createElement('audio');
                  audio.autoplay = true;
                  audio.playsInline = true;
                  audio.controls = false;
                  audio.style.display = 'none';
                  document.body.appendChild(audio);
                  
                  try {
                    if(typeof remoteTrack.play === 'function') {
                      remoteTrack.play(audio);
                    } else if(remoteTrack.track) {
                      const stream = new MediaStream([remoteTrack.track]);
                      audio.srcObject = stream;
                      audio.play().catch(()=>{});
                    }
                  } catch(e){ console.warn('could not auto-play remote track', e); }
                }
              }).catch(()=>{});
            }
          });
        }
      } catch(e){ console.warn('attachAgoraSession hook failed', e); }
      return true;
    }

    auth.onAuthStateChanged(async user => {
      if(!user) return;
      setVoiceStatus('Initializing voice...');
      
      try {
        if(typeof initAgoraVoice === 'function') {
          const maybePromise = initAgoraVoice({ firebase, auth, roomId, isHost, holdTalkBtn, voiceStatus });
          const session = (maybePromise && typeof maybePromise.then === 'function') ? await maybePromise : maybePromise;
          
          if(tryAttachAgoraSession(session)) {
            setVoiceStatus('Voice ready - hold to talk');
          } else {
            setVoiceStatus('Voice initialized');
            if(window.AgoraVoiceSession) tryAttachAgoraSession(window.AgoraVoiceSession);
          }
        } else if(window.AgoraVoiceSession) {
          tryAttachAgoraSession(window.AgoraVoiceSession);
          setVoiceStatus('Voice ready via global AgoraVoiceSession');
        } else {
          setVoiceStatus('Voice connector not found');
          console.warn('initAgoraVoice not found');
        }
      } catch (err) {
        console.error('Error initializing Agora:', err);
        setVoiceStatus('Voice init error');
      }
    });

    // Improved mic control functions
    async function startLocalMic() {
      try {
        if(agoraSession) {
          if(typeof agoraSession.publishLocalAudio === 'function') { 
            await agoraSession.publishLocalAudio(); 
            agoraLocalMicOn = true; 
            return true; 
          }
          if(typeof agoraSession.startLocalAudio === 'function') { 
            await agoraSession.startLocalAudio(); 
            agoraLocalMicOn = true; 
            return true; 
          }
          if(typeof agoraSession.unmuteLocalAudio === 'function') { 
            await agoraSession.unmuteLocalAudio(); 
            agoraLocalMicOn = true; 
            return true; 
          }
          if(typeof agoraSession.publish === 'function') { 
            await agoraSession.publish('audio').catch(()=>{}); 
            agoraLocalMicOn = true; 
            return true; 
          }
        }
        if(typeof window.startAgoraMic === 'function') { 
          await window.startAgoraMic(); 
          agoraLocalMicOn = true; 
          return true; 
        }
      } catch(e){ console.warn('startLocalMic error', e); }
      return false;
    }
    
    async function stopLocalMic() {
      try {
        if(agoraSession) {
          if(typeof agoraSession.unpublishLocalAudio === 'function') { 
            await agoraSession.unpublishLocalAudio(); 
            agoraLocalMicOn = false; 
            return true; 
          }
          if(typeof agoraSession.stopLocalAudio === 'function') { 
            await agoraSession.stopLocalAudio(); 
            agoraLocalMicOn = false; 
            return true; 
          }
          if(typeof agoraSession.muteLocalAudio === 'function') { 
            await agoraSession.muteLocalAudio(); 
            agoraLocalMicOn = false; 
            return true; 
          }
          if(typeof agoraSession.unpublish === 'function') { 
            await agoraSession.unpublish('audio').catch(()=>{}); 
            agoraLocalMicOn = false; 
            return true; 
          }
        }
        if(typeof window.stopAgoraMic === 'function') { 
          await window.stopAgoraMic(); 
          agoraLocalMicOn = false; 
          return true; 
        }
      } catch(e){ console.warn('stopLocalMic error', e); }
      return false;
    }

    // Improved PTT handlers with visual feedback
    function attachPTTHandlers(elem) {
      let touchStarted = false;
      
      elem.addEventListener('mousedown', async (e) => { 
        e.preventDefault(); 
        setVoiceStatus('Requesting mic...'); 
        const ok = await startLocalMic(); 
        if(ok){ 
          setVoiceStatus('You are talking'); 
          elem.classList.add('talking');
        } else { 
          setVoiceStatus('Mic failed ‚Äî check permissions'); 
        } 
      });
      
      elem.addEventListener('mouseup', async (e) => { 
        e.preventDefault(); 
        const ok = await stopLocalMic(); 
        if(ok) {
          setVoiceStatus('Mic off'); 
          elem.classList.remove('talking');
        } else {
          setVoiceStatus('Mic stop failed'); 
        }
      });
      
      elem.addEventListener('touchstart', async (e) => { 
        if(touchStarted) return;
        touchStarted = true;
        e.preventDefault(); 
        setVoiceStatus('Requesting mic...'); 
        const ok = await startLocalMic(); 
        if(ok){ 
          setVoiceStatus('You are talking'); 
          elem.classList.add('talking');
        } else { 
          setVoiceStatus('Mic failed ‚Äî check permissions'); 
        } 
      }, {passive:false});
      
      elem.addEventListener('touchend', async (e) => { 
        if(!touchStarted) return;
        touchStarted = false;
        e.preventDefault(); 
        const ok = await stopLocalMic(); 
        if(ok) {
          setVoiceStatus('Mic off'); 
          elem.classList.remove('talking');
        } else {
          setVoiceStatus('Mic stop failed'); 
        }
      }, {passive:false});
      
      // Also handle touch cancel
      elem.addEventListener('touchcancel', async (e) => {
        if(!touchStarted) return;
        touchStarted = false;
        e.preventDefault();
        const ok = await stopLocalMic();
        if(ok) {
          setVoiceStatus('Mic off (canceled)');
          elem.classList.remove('talking');
        }
      }, {passive:false});
    }
    
    attachPTTHandlers(holdTalkBtn);
    attachPTTHandlers(talkFloatingBtn);

    // Update floating talk visual
    function updateFloatingTalkVisual() {
      if(agoraLocalMicOn) {
        talkFloatingBtn.classList.add('talking');
        talkFloatingBtn.title = 'Talking ‚Äî release to stop';
      } else {
        talkFloatingBtn.classList.remove('talking');
        talkFloatingBtn.title = 'Hold to talk';
      }
    }
    setInterval(updateFloatingTalkVisual, 300);

    // --- Collapsible sections ---
    document.querySelectorAll('.collapsible-header').forEach(header => {
      header.addEventListener('click', function() {
        const content = this.nextElementSibling;
        const arrow = this.querySelector('span:last-child');
        
        if(content.classList.contains('collapsed')) {
          content.classList.remove('collapsed');
          arrow.textContent = '‚ñº';
        } else {
          content.classList.add('collapsed');
          arrow.textContent = '‚ñ∂';
        }
      });
    });

    // --- protect viewers from interacting with native controls ---
    if(!isHost){ 
      try{ 
        html5video.controls = false; 
        overlayBlock.classList.remove('hidden'); 
      }catch(e){} 
    }

    // hide floating controls unless fullscreen
    function updateFloatVisibility() {
      const fs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      floatControls.setAttribute('aria-hidden', fs ? 'false' : 'true');
    }
    document.addEventListener('fullscreenchange', updateFloatVisibility);
    document.addEventListener('webkitfullscreenchange', updateFloatVisibility);
    document.addEventListener('mozfullscreenchange', updateFloatVisibility);
    document.addEventListener('msfullscreenchange', updateFloatVisibility);
    updateFloatVisibility();

    // disable context menu on video for viewers
    document.addEventListener('contextmenu', e=>{ 
      if(!isHost && e.target === html5video) e.preventDefault(); 
    });

    // stop agora mic when leaving
    window.addEventListener('beforeunload', async () => {
      if(agoraLocalMicOn) await stopLocalMic().catch(()=>{});
    });

    // ensure fitCanvas is run once player sizes are known
    setTimeout(fitCanvas, 300);

    // small debug log
    console.info('Watch Party loaded. isHost=', isHost);
  </script>
</body>
</html>
